# 객체 지향 설계와 스프링 

## 자바 진영의 추운 겨울과 스프링의 탄생 이야기

### EJB

- 스프링 이전에는 2000년대 초반 EJB(Enterprise Java Beans)가 있었다.
  - 간단히 말하자면 스프링이랑 JPA(ORM) 등을 다 합쳐놓은 기술
  - 자바 진영의 표준 기술이었다.
  - 표준 기술이여서 많이 사용했다.
- EJB의 단점
  - 상당히 비쌌다.(한 대당 수 천 만원)
  - 진짜 어렵고, 복잡하고, 느리다!!
  - EJB가 제공하는 인터페이스 모두 구현하고 의존하게 된다.

> EJB는 지옥이야!!

- EJB를 사용했던 개발자 로드 존슨이 '스프링'을 개발함

### 스프링

- EJB 컨테이너 기술 대체
- EJB보다 단순함
- 현재 사실상 표준기술
- EJB를 사용하지 않아도 고품질의 확장 가능한 애플리케이션을 만들 수 있음
- Bean 팩토리, ApplicationContext, 제어의 역전, 의존관계 주입 등의 기술 포함
- 스프링의 의미: EJB(J2EE)라는 겨울을 넘어 봄(새로운 시작)이왔다는 의미.


### 하이버네이트

- EJB 엔티티빈 기술 대체
- 이 하이버네이트를 가지고 JPA라는 표준 기술을 만듬
- 현재 JPA는 표준 인터페이스가 되었고 하이버네이트는 JPA 구현체가 되었음

### 스프링 릴리즈
- XML 설정 지원(2003) --> 자바 코드 설정 지원 --> 스프링 부트(2014) 탄생
- 스프링 부트는 스프링 설정을 도와준다.
  - 톰캣이라는 웹 서버에다가 프로젝트를 war로 빌드한 후 배포하기 등 복잡했음
  - 스프링 부트는 설정을 자동으로 해주고 서버도 내장되어 있다.

## 스프링이란?

- 스프링은 하나의 기술이 아니라 **여러가지 기술의 집합**이다.
- 필수
  - 스프링 프레임워크
  - 스프링 부트
    - 스프링 프레임워크 기술들을 편리하게 사용하도록 도와주는 기술
- 선택
  - 스프링 시큐리티
    - 스프링 기반 보안 기
  - 스프링 배치
    - 대용량 레코드를 처리하는데 도움을 주는 기술
  - 스프링 데이터: 
    - 기본 데이터 저장소의 특징을 지키면서, 데이터에 접근할 때 편하게 해주는 스프링 기반 기술.
    - Spring Data JPA를 제일 많이 사용한다.
  - 스프링 세션
    - 세션 기능을 편리하게 도와주는 스프링 기반 기술
  - 스프링 클라우드
  - 스프링 Rest Docs
    - API 문서 테스트를 도와주는 기
  - 이 외에도 굉장히 많은 기술(프로젝트)이 있다.
    - Spring.io --> Projects --> Overview  
   
### 스프링 프레임워크
- 핵심 기술: 스프링 DI 컨테이, AOP, 이벤트
- 웹 기술: 스프링 MVC, 스프링 WebFlux
- 데이터 접근 기술: 트랜잭션, JDBC, ORM 지원, XML 지원
- 기술 통: 캐시, 이메일, 원격접근, 스케줄링
- 테스트: 스프링 기반 테스트 지원
- 언어: 코틀린, 그루비
- 위 모든 기술을 통합한 것을 스프링 프레임워크라고 한다.

### 스프링 부트 
- 스프링 프레임워크의 설정을 자동으로 해주는 기술
- 과거
  - 프로젝트를 빌드한다.
  - tomcat 웹서버를 설치한다.
  - tomcat 서버의 특정 위치에 빌드된 프로젝트를 넣는다.
  - 프로젝트를 띄운다.
- 스프링부트
  - 빌드하고 서버 띄우는 것도 자동적으로 해준다.
  - Tomcat 웹서버가 내장되어 있다.
- 최근에는 거의 대부분 프로젝트에서 사용한다.
- 외부 라이브러리 버전과 조합도 자동으로 설정해준다.
- 모니터링 기능 제공

### '스프링' 단어의 여러가지 의미

- '스프링'이라는 단어는 문맥에 따라 여러가지 의미를 가진다.
- 스프링 DI 컨테이너 기술 지칭(좁은 의미)
- 스프링 프레임워크 지
- 스프링 부트, 스프링 프레임워크 등 모두를 포함하는 스프링 생태계 지칭

### 스프링 왜 만들었을까? - 중요

- 왜 스프링이라는 기술을 만들었을까?
  - 자동 설정? 웹서버를 내장하고 있어서? DB 접근 기술? --> 부가적인 기능일 뿐
  - EJB는 객체지향적 애플리케이션을 만드는 것을 방해했다.
  - EJB에 의존적인 개발을 해야했기 때문이다.
  - 그래서 순수한 POJO(Plain Old Java Object)라는 운동까지 일어나게되었다.
  - 스프링 DI 컨테이너가 객체지향을 도와주었다.
- 이 기술의 핵심 원리는 무엇일까?
  - 스프링은 자바 언어 기반의 프레임워크다
  - 자바 언어의 가장 큰 특징은 **객체 지향 언어**라는 점이다.
  - 스프링은 객체 지향 언어가 가지는 강력한 특징을 살려주는 프레임워크다.
  - 스프링은 ** 좋은 객체 지향** 애플리케이션을 개발할 수 있게 도와주는 프레임워크다.
- 결론: 스프링은 객체지향 프로그램을 만들어주는 도구다.

> 그럼 좋은 객체 지향이란 뭘까? 

## 좋은 객체 지향 프로그래밍이란 무엇일까?

- 객체지향의 4가지 특징
  - 추상화
  - 상속
  - 캡슐화
  - **다형성**
- 역할, 책임, 협력하는 객체들의 모임
- 객체지향은 프로그램을 유연하고 변경하기 쉽게 만들어 준다.
  - 컴포넌트를 쉽게 갈아 끼울 수 있다.
  - **다형성(Polymorphism)**: 역할과 구현으로 분리하는 것

### 다형성 - 중요

- 역할 = 인터페이스
- 구현 = 인테페이스를 구현한 구현체
- 자동차 이야기
  - 자동차가 바뀌어도 운전자에게 영향을 주지 않는다라는게 포인트
  - 운전자는 자동차의 역할만 알고있다.
  - 즉, 다른 말로하면 운전자는 자동차 인터페이스에만 의존하고 있다.
  - = 자동차가 변해도 운전자관련 코드는 영향을 안받는다, 자동차 코드만 수정하면된다.
  - 세상을 바꾸지 않아도 새로운 자동차를 출시할 수 있다.
  - = 클라이언트에게 영향을 주지않고 새로운 기능을 제공할 수 있다.
  - 역할과 구현으로 세상을 분리했기 때문에 가능하다.
- 그런데 왜 이렇게 자동차 역할과 구현을 분리했을까? --> 운전자(클라이언트)를 위해
- 로미오 줄리엣 공연 이야기
  - 역할과 구현으로 분리되어있다.
  - 배우는 대체가 가능해야한다. 
  - 로미오 입장에서는 줄리엣 배우가 누군지 몰라도 된다. 


### 다형성: 역할과 구현을 분리

- 역할과 구현을 분리 --> 프로그램 단순, 유연, 변경이 편리
- 인터페이스를 안정적으로  잘 설계하는 것이 정말정말 중요하다!
  - 한계점: 역할, 즉 인터페이스 자체가 변하면 클라이언트, 서버 모두 큰 변화가 생긴다. 
- 장점
  - 클라이언트는 대상의 역할(인터페이스)만 알면된다. 
    - 즉, 인터페이스만 의존하면된다.
  - 클라이언트는 구현 대상의 **내부 구조를 몰라도** 된다.
    - 즉,어떻게(How) 동작하는지에 관심없다.
  - 클라이언트는 구현 대상의 **내부 구조가 변경되어도** 영향을 받지 않는다.
    - 즉, 클라이언트에게는 무엇(What)을 줄지만 주의하면된다.
  - 클라이언트는 구현 **대상 자체를 변경해도** 영향을 받지 않는다.
    - 즉, 클라이언트는 동작하는 방법(How)를 바꿔도 관심없다. 무엇(What)에게만 관심이 있다.
    - 설날 할아버지의 세벳돈
    - 손자는 할아버지의 세벳돈(What)에만 관심이있다.
    - 할아버지가 세벳돈을 주식으로 벌든, 일을해서 벌든(How) 생각을 하지 않는다.

### 자바 언어: 역할과 구현을 분리

- 자바 언어의 객체지향 특징인 다형성을 이용한다.
  - 역할 = 인터페이스
  - 구현 = 인터페이스를 구현한 클래스, 구현 객체
- 객체를 설계할 때 역할과 구현을 분리해서 설계하자
- 객체를 설계할 때 역할(인터페이스)를 먼저 부여하고, 그 역할을 수행하는 구현 객체를 만들자.
- 즉 핵심은 구현보다 역할이 먼저고 중요하다는 것이다.

### 자바 언어의 다형성

- 자바는 어떻게 다형성을 구현했을까?
- 오버라이딩
- 다형성으로 인터페이스를 구현한 객체를 실행 시점에 유연하게 변경할 수 있다.
- 물론 클래스의 상속 관계도 다형성, 오버라이딩 적용 가능.

<img width="1299" alt="image" src="https://user-images.githubusercontent.com/49191949/173263921-18ab7369-61ca-4116-854d-f93592401ed0.png">

- MemberService는 클라이언트 
- MemberRepository는 서버
- MemberService는 MemberRepository에 의존한다
  - 의존한다는 것 = 알고 있다
  - MemberService는 MemberRepository를 인스턴스 변수로 갖고있다.
  - 어떤 인스턴스를 할당하느냐에 따라 save()가 다른 것이 호출된다.

### 다형성의 본질

- 실행 시점에 인터페이스를 구현한 객체를 유연하게 변경할 수 있다.
- **클라이언트를 변경하지 않고 서버의 구현 기능을 유연하게 변경할 수 있다.**

### 스프링과 객체지향의 관계

- 다형성이 정말 중요하다!
  - 객체지향 특징 중 다형성이 제일 중요
- **스프링은 다형성을 극대화 시켜준다.**
- 스프링의 제어의 역전(IoC), 의존관계 주입(DI)는 다형성을 이용해서 역할 구현을 편리하게 분리할 수 있도록 도와준다.
- 스프링은 사용하면 레고 조립하듯이 구현부분 편리하게 변경할 수 있다.


> 그런데 스프링과 객체지향설계에 대해 제대로 이해하려면 다형성 외에 한 가지를 더 알아야 된다.
> --> 좋은 객체 지향 설계 원칙 5가지 SOLID


## 좋은 객체 지향 설계의 5가지 원칙(SOLID)

### 객체지향설계 5가지 원칙: SOLID
- 클린코드로 유명한 로버트 마틴이 만든 5가지 원칙
- SRP: 단일책임원(single responsibility principle)
- OCP: 개방-폐쇄 원칙(Open/closed principle)
- LSP: 리스코프 치환 원칙(Liskov substitution principle)
- ISP: 의존관계 역전 원칙(Dependency inversion principle)

### 단일책임원칙(SRP, Single Responsibility Principle)

- 하나의 클래스는 하나의 책임만 가져야 한다.
- 하나의 책임? 모호하네
  - 클 수도 있고, 작을 수도 있다.
  - 문맥과 상황에 따라 달라질 수 있다.
- SRP가 잘 적용되었는지 확인하는 방법: 변경
  - 변경이 있을 때 파급효과가 적으면 단일책임원칙을 잘 지킨 것이다.
  - 예) UI변경, 객체의 생성과 사용을 분리.

### 개방폐쇄원칙(OCP, Open/Closed Principle)

- 소프트웨어 요소는 확장에는 열려있고, 변경에는 닫혀있어야 한다.
- 다형성 활용한다.
- 가장 중요한 원칙
- 자동차 예시
  - 인터페이스를 구현하는 새로운 클래스를 만드는 것 --> 기존 코드 변경X

<img width="1289" alt="image" src="https://user-images.githubusercontent.com/49191949/173266182-ff21c23e-c122-4a5c-8566-aa4803ce3a68.png">

- MemberService 코드가 변경된다. --> OCP가 아닌데?

### 개방폐쇄원칙의 문제점

- MemberService 클라이언트가 구현 클래스를 직접 선택한다.
- 구현 객체를 변경하려면 클라이언트 코드를 변경해야하는 문제점이 생긴다.
- 분형 다형성을 사용했지만 OCP 원칙을 지킬 수 없다. = 기존 클라이언트 코드에 변경이 생긴다.
- 이 문제를 어떻게 해결해야 할까?
  - 객체를 생성하고, 연관관계를 맺어주는 별도의 조립, 설정자가 있어야 한다.
  - = 위의 역할을 스프링 컨테이너가 해준다!

### 리스코프 치환원칙(LSP, Liskov substitution Principle)

- 단순히 컴파일 수준을 넘어서 기능적으로 인터페이스 규약을 지켜야한다.
- 예) 자동차 인터페이스의 엑셀은 앞으로 가는 기능. 뒤로 가게 구현하면 LSP 위반, 느리더라도 앞으로 가야된다.

### 인터페이스 분리 원칙(ISP, Interface Segregation Principle)

- 특정 클라이언트를 위한 여러 인터페이스가 하나의 범용 인터페이스보다 낫다는 원칙
- 자동차 인터페이스 -> 운전 인터페이스, 정비 인터페이스로 분리하면
- 사용자 클라이언트 -> 운전자 클라이언트, 정비사 클라이언트로 분리할 수 있다.
- 분리하면 정비 인터페이스 자체가 변해도 운전자 클라이언트에 영향을 주지 않는다.
- ISP를 적용하면 인터페이스 명확해지고 대체 가능성이 높아진다.


### 의존관계역전원칙(DIP, Dependency Inversion Principle)

- 구현클래스에 의존하지말고 인터페이스에 의존해야한다는 원칙
- 프로그래머는 "추상화에 의존해야지 구체화에 의존하면 안된다."
- 같은말로 역할(Role)에 의존해야 한다.
- **클라이언트는 인터페이스에 의존해야 한다. 구현클래스에 의존하면 안된다.**
  - MemberService는 MemberRepository만 알아야하지 MemoryMemberRepository와 JDBCMemberRepository를 알면 안된다.
- 의존성 주입(DI)는 이 원칙을 따르는 방법 중 하나다.
- 2번째로 중요한 원칙
- 앞서 OCP에서 MemberService는 인터페이스에 의존하지만 동시에 구현 클래스애도 의존한다.
- MemberRepository m = new **MemoryMemberRepository()**;
- DIP 위반이다.

  <img width="1289" alt="image" src="https://user-images.githubusercontent.com/49191949/173266182-ff21c23e-c122-4a5c-8566-aa4803ce3a68.png">
  

### 정리

- 객체지향 특징중 다형성이 중요하다.
- 다형성만으로는 유연하고 변경이 용이하게 개발할 수 없다.
- = 다형성 만으로는 객체지향설계 5가지 원칙을 지킬 수 없다.
- 왜냐하면 구현 객체를 변경할 때 클라이언트 코드도 함께 변경되기 때문이다.
- **다형성 만으로는 OCP, DIP를 지킬 수 없다**

> 그럼 어떻게 해결해야하지? 

## 객체지향설계와 스프링

### 스프링 배우는 데 왜 객체지향 이야기가 나올까?

- 스프링은 다음 기술로 다형성과 OCP + DIP를 가능하도록 도와준다.
  - DI(Dependency Injection): 의존관계, 의존성 주입
  - DI 컨테이너 제공
    - 객체들을 컨테이너에 넣어놓고 의존관계 연결과 주입 기능을 제공해주는 컨테이너 
- 결국 스프링을 이용하면 클라이언트 코드의 변경없이 기능을 확장할 수 있다.
- 쉽게 부품을 교체하듯이 개발할 수 있다.


### 스프링 이전

- 객체지향 설계원칙인 OCP, DIP를 지키려고 개발을 해보니 너무 할일이 많았다.
  - 그래서 아예 프레임워크로 만들었다.
- 순수하게 자바로 OCP, DIP 원칙들을 지키면서 개발을 하면 결국 스프링 프레임워를 만들게된다.(더 정확히는 DI 컨테이너)
  
### 정리

- 이상적으로 모든 설계에 인터페이스를 부여하자

### 실무에서 고민

- 인터페이스가 좋지만 인터페이스를 도입하면 추상화라는 비용이 발생한다.
  - 즉, 개발자가 코드를 한번 더 들여다봐야한다.
  - 인터페이스만 보이니깐 한 번 더 들여가야하기 때문이다.
- 결론: 기능을 확장할 가능성이 없으면 구체 클래스를 직접 사용하고, 향후 꼭 필요할 때 리팩토링해서 인터페이스를 도입한

